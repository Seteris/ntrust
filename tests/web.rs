//! Test suite for the Web and headless browsers.
#![cfg(target_arch = "wasm32")]

extern crate hex;
extern crate wasm_bindgen_test;

use hex::FromHexError;
use wasm_bindgen_test::*;

wasm_bindgen_test_configure!(run_in_browser);

#[wasm_bindgen_test]
fn pass() {
    assert_eq!(1 + 1, 2);
}

#[wasm_bindgen_test]
fn test_owcpa_keypair() {
    assert_eq!(1, 1);
}

const TEST_DATA_SIZE: usize = 10;

#[derive(Debug, Copy, Clone)]
struct OwcpaKeypairTestData {
    test_data: [OwcpaKeypairTestSet; TEST_DATA_SIZE],
}

impl OwcpaKeypairTestData {
    pub fn new() -> OwcpaKeypairTestData {
        OwcpaKeypairTestData {
            test_data: [OwcpaKeypairTestSet::new(); TEST_DATA_SIZE]
        }
    }
    pub fn build(data: [OwcpaKeypairTestSet; TEST_DATA_SIZE]) -> OwcpaKeypairTestData {
        OwcpaKeypairTestData {
            test_data: data,
        }
    }
    pub fn provide(&self) -> OwcpaKeypairTestData {
        let mut test_data: [OwcpaKeypairTestSet; TEST_DATA_SIZE] = [OwcpaKeypairTestSet::new(); TEST_DATA_SIZE];
        hex::decode_to_slice("061550234D158C5EC95595FE04EF7A25767F2E24CC2BC479D09D86DC9ABCFDE7056A8C266F9EF97ED08541DBD2E1FFA1", &mut test_data[0].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[0].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[0].sk);

        hex::decode_to_slice("061550234D158C5EC95595FE04EF7A25767F2E24CC2BC479D09D86DC9ABCFDE7056A8C266F9EF97ED08541DBD2E1FFA1", &mut test_data[0].expected_seed);
        hex::decode_to_slice("EAD4D1AFF780D5AEAF590D73B44B01C8E45BC3B9EEC0B90290C7BCEED33849F3FDD6BA3D2C34EF5652FCAB9F76930EE4 \
        9B448AC494DFBC182A78F10DD70014EF9A61822D02497A1874452EF32DF3D7AD56BD52188F50FC21D3B782A90BF39276DF359A380BD0D92AFF9D926C44C3 \
        427731CF65F0955636C0E843A3AB04BD9043D0319D8B44817DD974514E73F0993C82BF01CA361DB7A201F9403391A2EDF959DE5E48980936C87D8801F744 \
        8F4453C07DC85BFE92DD6DBC94C0A45C69E8175117536BBE70D2C8E1F860B25AAF609402AA80DBED53610A75C238AB812082A937A46C4BF042A1809AF8A2 \
        B405DBC079AB7F731895A63C45328DF92BD6F262D17BBBA5857882762A25B58D806FEFB43455834028DBDE7F2C78B32A25B9EE4B144CA9F632F48E4DF6E8 \
        D082D7795D6175CC4A571E26884E630A7E734DDD522D93592BF9E2A55470E12226E5E4B03DCB0723C9912027E52298B3977A88B6342583BBFD0AC8C65030 \
        35AF0FC29E25EAA3C544F3B0F2C1C98C06F20372C59519CE30750DD555FD112A3E407D91C4131A411CC69329DE22971F1C746250DC5BD75F478AE18BC4E6 \
        0F520296D9578187886DE64EE0BC2D506888AFB23C5E3638C6D87CA93E9ED9354D1515B41CA2CD9FA1E03059F5D369EFCFBE1F77A87607AC102DD8971ECB \
        933D7C1AFE5570805E39E64DA0A273561914D270642112E5B3AF6F6B306FC79F75FE4460284212E48692A40F2462A069D527D2E283972686318934B090A7 \
        D257D98B139BFDA4031067F111065A202B3495554EBC87681802A8F18012AE244DF8AE4E59D97AE911D32018DDFD451BD67D8A331CA1240DEB2F6D3F6F5D \
        726F79946AD5248F362266BEA333DD1FCA1B9067185DC78900860414505A32431434E6F7CC86C068F872DEACC9D239DDC1C9863193C9A13B91492BA23B13 \
        E4C6D33BBA43E050910A6796109B4DC4198728750943A5CA6A6B7613AC400E", &mut test_data[0].expected_pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[0].expected_sk);

        hex::decode_to_slice("D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC81ADDE6AEEB4A5A875C3BFCADFA958F", &mut test_data[1].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[1].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[1].sk);

        hex::decode_to_slice("64335BF29E5DE62842C941766BA129B0643B5E7121CA26CFC190EC7DC3543830557FDD5C03CF123A456D48EFEA43C868", &mut test_data[2].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[2].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[2].sk);

        hex::decode_to_slice("225D5CE2CEAC61930A07503FB59F7C2F936A3E075481DA3CA299A80F8C5DF9223A073E7B90E02EBF98CA2227EBA38C1A", &mut test_data[3].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[3].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[3].sk);

        hex::decode_to_slice("EDC76E7C1523E3862552133FEA4D2AB05C69FB54A9354F0846456A2A407E071DF4650EC0E0A5666A52CD09462DBC51F9", &mut test_data[4].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[4].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[4].sk);

        hex::decode_to_slice("AA93649193C2C5985ACF8F9E6AC50C36AE16A2526D7C684F7A3BB4ABCD7B6FF790E82BADCE89BC7380D66251F97AAAAA", &mut test_data[5].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[5].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[5].sk);

        hex::decode_to_slice("2E014DC7C2696B9F6D4AF555CBA4B931B34863FF60E2341D4FDFE472FEF2FE2C33E0813FC5CAFDE4E30277FE522A9049", &mut test_data[6].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[6].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[6].sk);

        hex::decode_to_slice("AEFB28FDD34E0AB403A703B535296E3A545CA479C1D8148E2D501B3C8DD8B1034BD986F13F1A7B4671BE769359FD2AAB", &mut test_data[7].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[7].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[7].sk);

        hex::decode_to_slice("CBE5161E8DE02DDA7DE204AEB0FBB4CA81344BA8C30FE357A4664E5D2988A03B64184D7DC69F8D367550E5FEA0876D41", &mut test_data[8].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[8].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[8].sk);

        hex::decode_to_slice("B4663A7A9883386A2AE4CBD93787E247BF26087E3826D1B8DBEB679E49C0BB286E114F0E9F42F61F63DEC42B4F974846", &mut test_data[9].seed);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[9].pk);
        hex::decode_to_slice("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", &mut test_data[9].sk);

        OwcpaKeypairTestData {
            test_data
        }
    }

    pub fn pk_to_bytes(pk: [u8; CRYPTO_PUBLICKEYBYTES]) {}
    pub fn sk_to_bytes(sk: [u8; CRYPTO_PUBLICKEYBYTES]) {}
    pub fn seed_to_bytes(seed: [u8; CRYPTO_PUBLICKEYBYTES]) {}
}

#[derive(Debug, Copy, Clone)]
struct OwcpaKeypairTestSet {
    pk: [u8; CRYPTO_PUBLICKEYBYTES],
    sk: [u8; CRYPTO_SECRETKEYBYTES],
    seed: [u8; NTRU_SAMPLE_FG_BYTES],
    expected_pk: [u8; CRYPTO_PUBLICKEYBYTES],
    expected_sk: [u8; CRYPTO_SECRETKEYBYTES],
    expected_seed: [u8; NTRU_SAMPLE_FG_BYTES],
}

impl OwcpaKeypairTestSet {
    pub fn new() -> OwcpaKeypairTestSet {
        OwcpaKeypairTestSet {
            pk: [0; CRYPTO_PUBLICKEYBYTES],
            sk: [0; CRYPTO_SECRETKEYBYTES],
            seed: [0; NTRU_SAMPLE_FG_BYTES],
            expected_pk: [0; CRYPTO_PUBLICKEYBYTES],
            expected_sk: [0; CRYPTO_SECRETKEYBYTES],
            expected_seed: [0; NTRU_SAMPLE_FG_BYTES],
        }
    }
    pub fn build(pk: [u8; CRYPTO_PUBLICKEYBYTES],
                 sk: [u8; CRYPTO_SECRETKEYBYTES],
                 seed: [u8; NTRU_SAMPLE_FG_BYTES],
                 expected_pk: [u8; CRYPTO_PUBLICKEYBYTES],
                 expected_sk: [u8; CRYPTO_SECRETKEYBYTES],
                 expected_seed: [u8; NTRU_SAMPLE_FG_BYTES], ) -> OwcpaKeypairTestSet {
        OwcpaKeypairTestSet {
            pk,
            sk,
            seed,
            expected_pk,
            expected_sk,
            expected_seed,
        }
    }
}

// defines:
#[cfg(feature = "ntruhps2048509")]
pub const NTRU_N: usize = 509;
#[cfg(feature = "ntruhps2048677")]
pub const NTRU_N: usize = 677;
#[cfg(any(feature = "ntruhps2048509", feature = "ntruhps2048677"))]
pub const NTRU_LOGQ: usize = 11;
#[cfg(feature = "ntruhps4096821")]
pub const NTRU_N: usize = 821;
#[cfg(feature = "ntruhps4096821")]
pub const NTRU_LOGQ: usize = 12;
#[cfg(feature = "ntruhrss701")]
pub const NTRU_N: usize = 701;
#[cfg(feature = "ntruhrss701")]
pub const NTRU_LOGQ: usize = 13;

pub const NTRU_Q: usize = 1 << NTRU_LOGQ;

pub const NTRU_WEIGHT: usize = NTRU_Q / 8 - 2;

pub const NTRU_SAMPLE_IID_BYTES: usize = NTRU_N - 1;

pub const NTRU_SAMPLE_FT_BYTES: usize = (30 * (NTRU_N - 1) + 7) / 8;

#[cfg(any(feature = "ntruhps2048509", feature = "ntruhps2048677", feature = "ntruhps4096821"))]
pub const NTRU_SAMPLE_FG_BYTES: usize = NTRU_SAMPLE_IID_BYTES + NTRU_SAMPLE_FT_BYTES;
#[cfg(feature = "ntruhrss701")]
pub const NTRU_SAMPLE_FG_BYTES: usize = 2 * NTRU_SAMPLE_IID_BYTES;

#[cfg(any(feature = "ntruhps2048509", feature = "ntruhps2048677", feature = "ntruhps4096821"))]
pub const NTRU_SAMPLE_RM_BYTES: usize = NTRU_SAMPLE_IID_BYTES + NTRU_SAMPLE_FT_BYTES;
#[cfg(feature = "ntruhrss701")]
pub const NTRU_SAMPLE_RM_BYTES: usize = 2 * NTRU_SAMPLE_IID_BYTES;

pub const NTRU_PRFKEYBYTES: usize = 32;

pub const NTRU_PACK_DEG: usize = NTRU_N - 1;
pub const NTRU_PACK_TRINARY_BYTES: usize = (NTRU_PACK_DEG + 4) / 5;

pub const NTRU_OWCPA_MSGBYTES: usize = 2 * NTRU_PACK_TRINARY_BYTES;
pub const NTRU_OWCPA_BYTES: usize = (NTRU_LOGQ * NTRU_PACK_DEG + 7) / 8;
pub const NTRU_CIPHERTEXTBYTES: usize = NTRU_OWCPA_BYTES;

pub const NTRU_OWCPA_SECRETKEYBYTES: usize = 2 * NTRU_PACK_TRINARY_BYTES + NTRU_OWCPA_PUBLICKEYBYTES;
pub const NTRU_OWCPA_PUBLICKEYBYTES: usize = (NTRU_LOGQ * NTRU_PACK_DEG + 7) / 8;

// api

#[cfg(feature = "ntruhps2048509")]
pub const CRYPTO_PUBLICKEYBYTES: usize = 699;
#[cfg(feature = "ntruhps2048509")]
pub const CRYPTO_SECRETKEYBYTES: usize = 935;
#[cfg(feature = "ntruhps2048509")]
pub const CRYPTO_CIPHERTEXTBYTES: usize = 699;

#[cfg(feature = "ntruhps2048677")]
pub const CRYPTO_PUBLICKEYBYTES: usize = 930;
#[cfg(feature = "ntruhps2048677")]
pub const CRYPTO_SECRETKEYBYTES: usize = 1234;
#[cfg(feature = "ntruhps2048677")]
pub const CRYPTO_CIPHERTEXTBYTES: usize = 930;

#[cfg(feature = "ntruhps4096821")]
pub const CRYPTO_PUBLICKEYBYTES: usize = 1230;
#[cfg(feature = "ntruhps4096821")]
pub const CRYPTO_SECRETKEYBYTES: usize = 1590;
#[cfg(feature = "ntruhps4096821")]
pub const CRYPTO_CIPHERTEXTBYTES: usize = 1230;

#[cfg(feature = "ntruhrss701")]
pub const CRYPTO_PUBLICKEYBYTES: usize = 1138;
#[cfg(feature = "ntruhrss701")]
pub const CRYPTO_SECRETKEYBYTES: usize = 1450;
#[cfg(feature = "ntruhrss701")]
pub const CRYPTO_CIPHERTEXTBYTES: usize = 1138;

pub const CRYPTO_BYTES: usize = 32;